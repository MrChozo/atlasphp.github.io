[{"id":"\/mapper\/getting-started.html#1-1-1","title":"1.1.1. Installation","content":"This package is installable and autoloadable via Composer as atlas\/orm. Add the following lines to your composer.json file, then call composer update.{ \"require\": { \"atlas\/orm\": \"~1.0\" }, \"require-dev\": { \"atlas\/cli\": \"~1.0\" } } (The atlas\/cli package provides the atlas-skeleton command-line tool to help create skeleton classes for the mapper.)"},{"id":"\/mapper\/getting-started.html#1-1-2","title":"1.1.2. Creating Data Source Classes","content":"You can create your data source classes by hand, but it's going to be tedious to do so. Instead, use the atlas-skeleton command to read the table information from the database. You can read more about that in the atlas\/cli docs."},{"id":"\/mapper\/getting-started.html#1-1-3","title":"1.1.3. Instantiating Atlas","content":"Create an Atlas instance using the AtlasContainer.The container accepts a PDO, ExtendedPdo or ConnectionLocator instance or you can enter connection parameters and the container creates a connection for you.&lt;?php $atlasContainer = new AtlasContainer(new PDO(...)); \/\/ or $atlasContainer = new AtlasContainer(new ExtendedPdo(...)); \/\/ or $atlasContainer = new AtlasContainer(new ConnectionLocator(...)); \/\/ or $atlasContainer = new AtlasContainer( 'mysql:host=localhost;dbname=testdb', 'username', 'password' ); Next, set the available mapper classes into the container.&lt;?php $atlasContainer-&gt;setMappers([ AuthorMapper::CLASS, ReplyMapper::CLASS, SummaryMapper::CLASS, TagMapper::CLASS, ThreadMapper::CLASS, TaggingMapper::CLASS, ]); Finally, get back the Atlas instance out of the container.&lt;?php $atlas = $atlasContainer-&gt;getAtlas(); "},{"id":"\/mapper\/relationships.html#1-2","title":"1.2. Mapper Relationships","content":"You can add relationships to a mapper inside its setRelated() method, calling one of the four available relationship-definition methods: oneToOne($field, $mapperClass) (aka \"has one\") manyToOne($field, $mapperClass) (aka \"belongs to\") oneToMany($field, $mapperClass) (aka \"has many\") manyToMany($field, $mapperClass, $throughField) (aka \"has many through\") The $field will become a field name on the returned Record object. That field will be populated from the specified $mapperClass in Atlas. (In the case of manyToMany(), the association mappings will come from the specified $throughField.)Here is an example:&lt;?php namespace App\\DataSource\\Thread; use App\\DataSource\\Author\\AuthorMapper; use App\\DataSource\\Summary\\SummaryMapper; use App\\DataSource\\Reply\\ReplyMapper; use App\\DataSource\\Tagging\\TaggingMapper; use App\\DataSource\\Tag\\TagMapper; use Atlas\\Orm\\Mapper\\AbstractMapper; class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;manyToOne('author', AuthorMapper::CLASS); $this-&gt;oneToOne('summary', SummaryMapper::CLASS); $this-&gt;oneToMany('replies', ReplyMapper::CLASS); $this-&gt;oneToMany('taggings', TaggingMapper::CLASS); $this-&gt;manyToMany('tags', TagMapper::CLASS, 'taggings'); } } "},{"id":"\/mapper\/relationships.html#1-2-1","title":"1.2.1. Relationship Key Columns","content":"By default, in all relationships except many-to-one, the relationship will take the primary key column(s) in the native table, and map to those same column names in the foreign table.In the case of many-to-one, it is the reverse; that is, the relationship will take the primary key column(s) in the foreign table, and map to those same column names in the native table.If you want to use different columns, call the on() method on the relationship. For example, if the threads table uses author_id, but the authors table uses just id, you can do this:&lt;?php class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;oneToOne('author', AuthorMapper::CLASS) -&gt;on([ \/\/ native (threads) column =&gt; foreign (authors) column 'author_id' =&gt; 'id', ]); \/\/ ... } } "},{"id":"\/mapper\/relationships.html#1-2-2","title":"1.2.2. Composite Relationship Keys","content":"Likewise, if a table uses a composite key, you can re-map the relationship on multiple columns. If table foo has composite primary key columns of acol and bcol, and it maps to table bar on foo_acol and foo_bcol, you would do this:&lt;?php class FooMapper { protected function setRelated() { $this-&gt;oneToMany('bars', BarMapper::CLASS) -&gt;on([ \/\/ native (foo) column =&gt; foreign (bar) column 'acol' =&gt; 'foo_acol', 'bcol' =&gt; 'foo_bcol', ]); } } "},{"id":"\/mapper\/relationships.html#1-2-3","title":"1.2.3. Case-Sensitivity","content":" N.b.: This applies only to string-based relationship keys. If you are using numeric relationship keys, this section does not apply. Atlas will match records related by string keys in a case-senstive manner. If your collations on the related string key columns are not case sensitive, Atlas might not match up related records properly in memory after fetching them from the database. This is because 'foo' and 'FOO' might be equivalent in the database collation, but they are not equivalent in PHP.In that kind of situation, you will want to tell the relationship to ignore the case of related string key columns when matching related records. You can do so with the ignoreCase() method on the relationship definition. &lt;?php class FooMapper { protected function setRelated() { $this-&gt;oneToMany('bars', BarMapper::CLASS) -&gt;ignoreCase(); } } With that in place, a native value of 'foo' match to a foreign value of 'FOO' when Atlas is stitching together related records."},{"id":"\/mapper\/relationships.html#1-2-4","title":"1.2.4. Simple WHERE Conditions","content":"You may find it useful to define simple WHERE conditions on the foreign side of the relationship. For example, you can handle one side of a so-called polymorphic relationship by selecting only related records of a particular type.In the following example, a comments table has a commentable_id column as the foreign key value, but is restricted to \"issue\" values on a discriminator column named commentable.class IssueMapper extends AbstractMapper { protected function setRelated() { $this-&gt;oneToMany('comments', CommentMapper::CLASS) -&gt;on([ 'issue_id' =&gt; 'commentable_id' ]) -&gt;where('commentable = ?', 'issue'); } } (These conditions will be honored by MapperSelect::*joinWith() as well.)"},{"id":"\/mapper\/reading.html#1-3","title":"1.3. Reading Records From The Database","content":"Use Atlas to retrieve a single Record, or many Records in a RecordSet, from the database."},{"id":"\/mapper\/reading.html#1-3-1","title":"1.3.1. Reading A Record","content":"Use the fetchRecord() method to retrieve a single Record. It can be called either by primary key, or with a select() query.&lt;?php \/\/ fetch by primary key thread_id = 1 $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::class, '1' ); $threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', '1') -&gt;fetchRecord(); (Note that the select() variation gives you access to all the underlying SQL query methods.)If fetchRecord() does not find a match, it will return false."},{"id":"\/mapper\/reading.html#1-3-2","title":"1.3.2. Reading A RecordSet","content":"The fetchRecordSet() method works the same as fetchRecord(), but for multiple Records. It can be called either with primary keys, or with a select() query.&lt;?php \/\/ fetch thread_id 1, 2, and 3 $threadRecordSet = $atlas-&gt;fetchRecordSet( ThreadMapper::CLASS, [1, 2, 3] ); $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;where('thread_id IN (?)', [1, 2, 3]) -&gt;fetchRecordSet(); (Note that the select() variation gives you access to all the underlying SQL query methods.)If fetchRecordSet() does not find any matches, it will return an empty array."},{"id":"\/mapper\/reading.html#1-3-3","title":"1.3.3. Reading Relateds","content":"Any relationships that are set in the Mapper will appear as NULL in the Record object. Related data will only be populated if it explicitly requested as part of the fetch or select.On a fetch*(), load relateds using a third argument: an array specifying which related fields to retrieve.&lt;?php $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, '1', [ 'author', 'summary', 'replies', ] ); $threadRecordSet = $atlas-&gt;fetchRecordSet( ThreadMapper::CLASS, [1, 2, 3], [ 'author', 'summary', 'replies', ] ); On a select(), load relateds using the with() method:$threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', '1') -&gt;with([ 'author', 'summary', 'replies', ]) -&gt;fetchRecord(); $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;where('thread_id IN (?)', [1, 2, 3]) -&gt;with([ 'author', 'summary', 'replies', ]) -&gt;fetchRecordSet(); Relationships can be nested as deeply as needed. For example, to fetch the author of each reply on each thread:&lt;?php $threadRecord = $this-&gt;atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', $threadId) -&gt;with([ 'author', 'summary', 'replies' =&gt; [ 'author' ] ]) -&gt;fetchRecord(); Alternatively, you can pass a closure to exercise fine control over the query that fetches the relateds:&lt;?php \/\/ fetch thread_id 1; with only the last 10 related replies in descending order; \/\/ including each reply author $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, '1', [ 'author', 'summary', 'replies' =&gt; function ($selectReplies) { $selectReplies -&gt;limit(10) -&gt;orderBy(['reply_id DESC']) -&gt;with([ 'author' ]); }, ] ); "},{"id":"\/mapper\/reading.html#1-3-4","title":"1.3.4. Reading Record Counts","content":"If you use a select() to fetch a RecordSet with a limit() or page(), you can re-use the select to get a count of how many Records would have been returned. This can be useful for paging displays.&lt;?php $select = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;with([ 'author', 'summary', 'replies' ]) -&gt;limit(10) -&gt;offset(20); $threadRecordSet = $select-&gt;fetchRecordSet(); $countOfAllThreads = $select-&gt;fetchCount(); "},{"id":"\/mapper\/records.html#1-4","title":"1.4. Working With Records","content":"Once you have a Record, you can access its underlying Row and Related data as properties.&lt;?php \/\/ fetch thread id 1 with related replies, and each reply author $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, 1, [ 'replies' =&gt; [ 'author', ], ] ); echo $threadRecord-&gt;title; echo $threadRecord-&gt;body; foreach ($threadRecord-&gt;replies as $replyRecord) { echo $replyRecord-&gt;author-&gt;name; echo $replyRecord-&gt;body; } Make changes to the Record by setting new property values.&lt;?php $threadRecord-&gt;title = \"Thread title\"; $threadRecord-&gt;body = \"Body text for the thread\"; Note that the Row supporting each Record is identity-mapped, so a change to a Row used by more than one Record will be reflected immediately in each Record using that Row.&lt;?php \/\/ if the reply rows are different, but the author of each reply \/\/ is the same, the reply author objects are the same. $threadRecord -&gt;replies[0] -&gt;author -&gt;name = \"New name\"; \/\/ $threadRecord-&gt;replies[1]-&gt;author-&gt;name is now also \"New name\" "},{"id":"\/mapper\/records.html#1-4-1","title":"1.4.1. New Records","content":"Create a new Record using the newRecord() method, optionally passing any data you want to initially populate into the Record.&lt;?php $threadRecord = $atlas-&gt;newRecord( ThreadMapper::CLASS, [ 'title' =&gt; 'New Thread Title', ] ); Note that this does not insert the Record into the database."},{"id":"\/mapper\/records.html#1-4-2","title":"1.4.2. JSON Encoding","content":"JSON-encoding a Record is trivial:&lt;?php $json = json_encode($threadRecord); "},{"id":"\/mapper\/record-sets.html#1-5","title":"1.5. Working With RecordSets","content":"Once you have a RecordSet, you can iterate over it.&lt;?php \/\/ fetch the top 100 threads $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;orderBy(['thread_id DESC']) -&gt;limit(100) -&gt;fetchRecordSet(); foreach ($threadRecordSet as $threadRecord) { echo $threadRecord-&gt;title; } "},{"id":"\/mapper\/record-sets.html#1-5-1","title":"1.5.1. Array Access","content":"The RecordSet also acts as an array, so you can get\/set\/unset Records by their sequential keys in the RecordSet.&lt;?php \/\/ address the second record in the set $threadRecordSet[1]-&gt;title = 'Changed Title'; \/\/ unset the first record in the set unset($threadRecordSet[0]); \/\/ push a new record onto the set $threadRecordSet[] = $atlas-&gt;newRecord(ThreadMapper::CLASS); "},{"id":"\/mapper\/record-sets.html#1-5-2","title":"1.5.2. Appending","content":"You can append a new Record using appendNew(), optionally passing any data you want to initially populate into the Record:&lt;?php $newThread = $threadRecordSet-&gt;appendNew([ 'title' =&gt; 'New Title', ]); Note that this only adds the Record to the RecordSet; it does not insert the Record into the database."},{"id":"\/mapper\/record-sets.html#1-5-3","title":"1.5.3. Searching","content":"You can search for Records by their column values:&lt;?php \/\/ returns one matching Record object from the RecordSet, \/\/ or false if there is no match $matchingRecord = $threadRecordSet-&gt;getOneBy(['subject' =&gt; 'Subject One']); \/\/ returns an array of matching Record objects from the RecordSet $matchingRecords = $threadRecordSet-&gt;getAllBy(['author_id' =&gt; '5']); "},{"id":"\/mapper\/record-sets.html#1-5-4","title":"1.5.4. Removing","content":"You can remove Records by their column values.&lt;?php \/\/ unsets and returns one matching Record from the Record Set, \/\/ or false if there is no match $removedRecord = $threadRecordSet-&gt;removeOneBy(['subject' =&gt; 'Subject One']); \/\/ unsets and returns an array of matching Record objects from the Record Set $removedRecords = $threadRecordSet-&gt;removeAllBy(['author_id' =&gt; '5']); Note that this only removes them from the RecordSet; it does not delete them from the database."},{"id":"\/mapper\/record-sets.html#1-5-5","title":"1.5.5. New RecordSets","content":"Create a new RecordSet using the newRecordSet() method.&lt;?php $threadRecordSet = $atlas-&gt;newRecordSet(ThreadMapper::CLASS); "},{"id":"\/mapper\/record-sets.html#1-5-6","title":"1.5.6. JSON Encoding","content":"JSON-encoding a RecordSet is trivial:&lt;?php $json = json_encode($threadRecordSet); "},{"id":"\/mapper\/record-sets.html#1-5-7","title":"1.5.7. Other Methods","content":"Other RecordSet methods include:&lt;?php $array = $recordSet-&gt;getArrayCopy(); $isEmpty = empty($threadRecordSet); $count = count($threadRecordSet); "},{"id":"\/mapper\/writing.html#1-6-1","title":"1.6.1. Individual Writes","content":"You can write a single Record back to the database by using the Atlas insert(), update(), and delete() methods. These will use the appropriate Mapper for the Record to perform the write within a transaction, and capture any exceptions that occur along the way.&lt;?php $success = $atlas-&gt;insert($record); \/\/ or update(), or delete() if ($success) { echo \"Wrote the Record back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } Inserting a Record with an auto-incrementing primary key will automatically modify the Record to set the last-inserted ID.Inserting or updating a Record will automatically set the foreign key fields on the native Record, and on all the loaded relationships for that Record.The insert(), update(), and delete() methods write only the one Row for that Record back to the database. They will not automatically operate on related fields."},{"id":"\/mapper\/writing.html#1-6-2","title":"1.6.2. Persisting Related Records","content":"If you like, you can persist a Record and all of its loaded relationships (and all of their loaded relationships, etc.) back to the database using the Atlas persist() method. This is good for straightforward relationship structures where the order of write operations does not need to be closely managed.The persist() method will: persist many-to-one and many-to-many relateds loaded on the native Record; persist the native Record by ... inserting the Row for the Record if it is new; or, updating the Row for the Record if it has been modified; or, deleting the Row for the Record if the Record has been marked for deletion using the Record::markForDeletion() method; persist one-to-one and one-to-many relateds loaded on the native Record. &lt;?php $success = $atlas-&gt;persist($record); if ($success) { echo \"Wrote the Record and all of its relateds back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } As with insert and update, this will automatically set the foreign key fields on the native Record, and on all the loaded relationships for that Record.If a related field is not loaded, it cannot be persisted automatically.Note that whether or not the Row for the Record is inserted\/updated\/deleted, the persist() method will still recursively traverse all the related fields and persist them as well.The delete() method will not attempt to cascade deletion or nullification across relateds at the ORM level. Your database may have cascading set up at the database level; Atlas has no control over this."},{"id":"\/mapper\/writing.html#1-6-3","title":"1.6.3. Unit of Work","content":"If you make changes to several Records, you can write them back to the database using a unit-of-work Transaction. You can plan for Records to be inserted, updated, and deleted, in whatever order you like, and then execute the entire transaction plan at once. Exceptions will cause a rollback.&lt;?php \/\/ create a transaction $transaction = $atlas-&gt;newTransaction(); \/\/ plan work for the transaction $transaction-&gt;insert($record1); $transaction-&gt;update($record2); $transaction-&gt;delete($record3); \/\/ or persist an entire record and its relateds $transaction-&gt;persist($record4); \/\/ execute the transaction plan $success = $transaction-&gt;exec(); if ($success) { echo \"The Transaction succeeded!\"; } else { \/\/ get the exception that was thrown in the transaction $e = $transaction-&gt;getException(); \/\/ get the work element that threw the exception $work = $transaction-&gt;getFailure(); \/\/ some output echo \"The Transaction failed: \"; echo $work-&gt;getLabel() . ' threw ' . $e-&gt;getMessage(); } "},{"id":"\/mapper\/direct.html#1-7","title":"1.7. Direct Queries","content":"If you need to perform queries directly, additional fetch* and yield* methods are provided which expose the Extended PDO functionality. By using the $cols parameter, you can select specific columns or individual values. For example:&lt;?php \/\/ an array of IDs $threadIds = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id']) -&gt;limit(10) -&gt;orderBy('thread_id DESC') -&gt;fetchCol(); \/\/ key-value pairs of IDs and titles $threadIdsAndTitles = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'tite']) -&gt;limit(10) -&gt;orderBy('thread_id DESC') -&gt;fetchPairs(); \/\/ etc. See the list of ExtendedPdo::fetch*() and yield*() methods for more.You can also call fetchRow() or fetchRows() to get Row objects directly from the Table underlying the Mapper."},{"id":"\/mapper\/direct.html#1-7-1-1","title":"1.7.1.1. Fetch Value","content":"Returns a single value, or false.&lt;?php $subject = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;where('thread_id = ?', '1') -&gt;fetchValue(); \/\/ \"Subject One\" "},{"id":"\/mapper\/direct.html#1-7-1-2","title":"1.7.1.2. Fetch Column","content":"Returns a sequential array of one column, or an empty array.&lt;?php $subjects = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;limit(2) -&gt;fetchCol(); \/\/ [ \/\/ 0 =&gt; \"Subject One\", \/\/ 1 =&gt; \"Subject Two\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-7-1-3","title":"1.7.1.3. Fetch Pairs","content":"Returns an associative array where the key is the first column and the value is the second column, or an empty array.&lt;?php $subjectAndBody = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;fetchPairs(); \/\/ [ \/\/ 'Subject One' =&gt; \"Body Text One\", \/\/ 'Subject Two' =&gt; \"Body Text Two\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-7-1-4","title":"1.7.1.4. Fetch One","content":"Returns an associative array of one row, or false.&lt;?php $threadData = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body', 'author_id']) -&gt;where('thread_id = 1') -&gt;fetchOne(); \/\/ [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\", \/\/ 'author_id' =&gt; \"1\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-7-1-5","title":"1.7.1.5. Fetch Assoc","content":"Returns an associative array of rows keyed on the first column specified, or an empty array.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;fetchAssoc(); \/\/ [ \/\/ 'Subject One' =&gt; [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\", \/\/ ], \/\/ 'Subject Two' =&gt; [ \/\/ 'subject' =&gt; \"Subject Two\", \/\/ 'body' =&gt; \"Body Text Two\" \/\/ ] \/\/ ] "},{"id":"\/mapper\/direct.html#1-7-1-6","title":"1.7.1.6. Fetch All","content":"Returns a sequential array of associative arrays, or an empty array.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;orderBy('thread_id DESC') -&gt;fetchAll(); \/\/ [ \/\/ 0 =&gt; [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\" \/\/ ], \/\/ 1 =&gt; [ \/\/ 'subject' =&gt; \"Subject Two\", \/\/ 'body' =&gt; \"Body Text Two\" \/\/ ] \/\/ ] "},{"id":"\/mapper\/direct.html#1-7-2","title":"1.7.2. Yielding Data","content":"If you prefer to get the results one at a time, you can use the yield* variations on these methods to iterate through the result set instead of returning an array."},{"id":"\/mapper\/direct.html#1-7-2-1","title":"1.7.2.1. Yield Col","content":"Iterate through a sequential array of one column.&lt;?php $subjects = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;yieldCol(); foreach($subjects as $subject) { echo $subject; } "},{"id":"\/mapper\/direct.html#1-7-2-2","title":"1.7.2.2. Yield Pairs","content":"Iterate through an associative array by the first column specified.&lt;?php $subjectAndBody = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;yieldPairs(); foreach($subjectAndBody as $subject =&gt; $body) { echo $subject . \": \" . $body; } "},{"id":"\/mapper\/direct.html#1-7-2-3","title":"1.7.2.3. Yield Assoc","content":"Iterate through an associative array of rows by the first column specified.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'subject']) -&gt;yieldAssoc(); foreach($threads as $threadId =&gt; $thread) { echo $threadId . \": \" . $thread['subject']; } "},{"id":"\/mapper\/direct.html#1-7-2-4","title":"1.7.2.4. Yield All","content":"Iterate through a sequential array of rows.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'subject']) -&gt;yieldAll(); foreach($threads as $thread) { echo $thread['thread_id'] . \": \" . $thread['subject']; } "},{"id":"\/mapper\/direct.html#1-7-3","title":"1.7.3. Complex Queries","content":"You can use any of the direct table access methods with more complex queries and joins.&lt;?php $threadData = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['threads.subject', 'authors.name', 's.*']) -&gt;join('INNER', 'authors', 'authors.author_id = threads.author_id') -&gt;join('INNER', 'summary s', 's.thread_id = threads.thread_id') -&gt;where('authors.name = ?', $name) -&gt;orderBy('threads.thread_id DESC') -&gt;offset(2) -&gt;limit(2) -&gt;fetchAssoc(); "},{"id":"\/mapper\/direct.html#1-7-4","title":"1.7.4. Reusing the Select","content":"The select object can be used for multiple queries, which may be useful for pagination. The generated select statement can also be displayed for debugging purposes.&lt;?php $select = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['*']) -&gt;offset(10) -&gt;limit(5); \/\/ Fetch the current result set $results = $select-&gt;fetchAll(); \/\/ Fetch the row count without any limit or offset $totalCount = $select-&gt;fetchCount(); \/\/ View the generated select statement $statement = $select-&gt;getStatement(); "},{"id":"\/mapper\/domain.html#1-8","title":"1.8. Domain Models","content":"You can go a long way with just your persistence model Records. However, at some point you may want to separate your persistence model Records from your domain model Entities and Aggregates. This section offers some suggestions and examples on how to do that."},{"id":"\/mapper\/domain.html#1-8-1","title":"1.8.1. Persistence Model","content":"For the examples below, we will work with an imaginary forum application that has conversation threads. The ThreadMapper might something like this:&lt;?php namespace App\\DataSource\\Thread; use App\\DataSource\\Author\\AuthorMapper; use App\\DataSource\\Summary\\SummaryMapper; use App\\DataSource\\Reply\\ReplyMapper; use App\\DataSource\\Tagging\\TaggingMapper; use App\\DataSource\\Tag\\TagMapper; use Atlas\\Orm\\Mapper\\AbstractMapper; class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;manyToOne('author', AuthorMapper::CLASS); $this-&gt;oneToOne('summary', SummaryMapper::CLASS); $this-&gt;oneToMany('replies', ReplyMapper::CLASS); $this-&gt;oneToMany('taggings', TaggingMapper::CLASS); $this-&gt;manyToMany('tags', TagMapper::CLASS, 'taggings'); } } (We will leave the other mappers and their record classes for the imagination.)"},{"id":"\/mapper\/domain.html#1-8-2","title":"1.8.2. Domain Model Interfaces","content":"At some point, we have decided we want to depend on domain Entities or Aggregates, rather than persistence Records, in our application.For example, the interface we want to use for a Thread Entity in domain might look like this:&lt;?php namespace App\\Domain\\Thread; interface ThreadInterface { public function getId(); public function getSubject(); public function getBody(); public function getDatePublished(); public function getAuthorId(); public function getAuthorName(); public function getTags(); public function getReplies(); } (This interface allows us to typehint the application against these domain- specific Entity methods, rather than using the persistence Record properties.)Further, we will presume a naive domain repository implementation that returns Thread Entities. It might look something like this:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadMapper; class ThreadRepository { protected $mapper; public function __construct(ThreadMapper $mapper) { $this-&gt;mapper = $mapper; } public function fetchThread($thread_id) { $record = $this-&gt;mapper-&gt;fetchRecord($thread_id, [ 'author', 'taggings', 'tags', 'replies', ]); return $this-&gt;newThread($record); } protected function newThread(ThreadRecord $record) { \/* ??? *\/ } } The problem now is the newThread() factory method. How do we convert a persistence layer ThreadRecord into a domain layer ThreadInterface implementation?There are three options, each with different tradeoffs: Implement the domain interface in the persistence layer. Compose the persistence record into the domain object. Map the persistence record fields to domain implementation fields. "},{"id":"\/mapper\/domain.html#1-8-3","title":"1.8.3. Implement Domain In Persistence","content":"The easiest thing to do is to implement the domain ThreadInterface in the persistence ThreadRecord, like so:&lt;?php namespace App\\DataSource\\Thread; use Atlas\\Orm\\Mapper\\Record; use App\\Domain\\Thread\\ThreadInterface; class ThreadRecord extends Record implements ThreadInterface { public function getId() { return $this-&gt;thread_id; } public function getTitle() { return $this-&gt;title; } public function getBody() { return $this-&gt;body; } public function getDatePublished() { return $this-&gt;date_published; } public function getAuthorId() { return $this-&gt;author-&gt;author_id; } public function getAuthorName() { return $this-&gt;author-&gt;name; } public function getTags() { return $this-&gt;tags-&gt;getArrayCopy(); } public function getReplies() { return $this-&gt;replies-&gt;getArrayCopy(); } } With this, the ThreadRepository::newThread() factory method doesn't actually need to factory anything at all. It just returns the persistence record, since the record now has the domain interface.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return $record; } Pros: Trivial to implement. Cons: Exposes the persistence layer Record methods and properties to the domain layer, where they can be easily abused. "},{"id":"\/mapper\/domain.html#1-8-4","title":"1.8.4. Compose Persistence Into Domain","content":"Almost as easy, but with better separation, is to have a domain layer object that implements the domain interface, but encapsulates the persistence record as the data source. The domain object might look something like this:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadRecord; class Thread implements ThreadInterface { protected $record; public function __construct(ThreadRecord $record) { $this-&gt;record = $record; } public function getId() { return $this-&gt;record-&gt;thread_id; } public function getTitle() { return $this-&gt;record-&gt;title; } public function getBody() { return $this-&gt;record-&gt;body; } public function getDatePublished() { return $this-&gt;record-&gt;date_published; } public function getAuthorId() { return $this-&gt;record-&gt;author-&gt;author_id; } public function getAuthorName() { return $this-&gt;record-&gt;author-&gt;name; } public function getTags() { return $this-&gt;record-&gt;tags-&gt;getArrayCopy(); } public function getReplies() { return $this-&gt;record-&gt;replies-&gt;getArrayCopy(); } } Now the ThreadRepository::newThread() factory method has to do a little work, but not much. All it needs is to create the Thread domain object with the ThreadRecord as a constructor dependency.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return new Thread($record); } Pros: Hides the persistence record behind the domain interface. Easy to implement. Cons: The domain object is now dependent on the persistence layer, which is not the direction of dependencies we'd prefer. "},{"id":"\/mapper\/domain.html#1-8-5","title":"1.8.5. Map From Persistence To Domain","content":"Most difficult, but with the best separation, is to map the individual parts of the persistence record over to a \"plain old PHP object\" (POPO) in the domain, perhaps something like the following:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadRecord; class Thread implements ThreadInterface { protected $id; protected $title; protected $body; protected $datePublished; protected $authorId; protected $authorName; protected $tags; protected $replies; public function __construct( $id, $title, $body, $datePublished, $authorId, $authorName, array $tags, array $replies ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;body = $body; $this-&gt;datePublished = $datePublished; $this-&gt;authorId = $authorId; $this-&gt;authorName = $authorName; $this-&gt;tags = $tags; $this-&gt;replies = $replies; } public function getId() { return $this-&gt;id; } public function getTitle() { return $this-&gt;title; } public function getBody() { return $this-&gt;body; } public function getDatePublished() { return $this-&gt;datePublished; } public function getAuthorId() { return $this-&gt;authorId; } public function getAuthorName() { return $this-&gt;authorName; } public function getTags() { return $this-&gt;tags; } public function getReplies() { return $this-&gt;replies; } } Now the ThreadRepository::newThread() factory method has a lot of work to do. It needs to map the individual fields in the persistence record to the domain object properties.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return new Thread( $record-&gt;thread_id, $record-&gt;title, $record-&gt;body, $record-&gt;date_published, $record-&gt;author-&gt;author_id, $record-&gt;author-&gt;name, $record-&gt;tags-&gt;getArrayCopy(), $record-&gt;replies-&gt;getArrayCopy() ); } ?&gt; Pros: Offers true separation of domain from persistence. Cons: Tedious and time-consuming to implement. "},{"id":"\/mapper\/domain.html#1-8-6","title":"1.8.6. Which Approach Is Best?","content":"\"It depends.\" What does it depend on? How much time you have available, and what kind of suffering you are willing to put up with.If you need something quick, fast, and in a hurry, implementing the domain interface in the persistence layer will do the trick. However, it will come back to bite in you just as quickly, as you begin to realize that you need different domain behaviors in different contexts, all built from the same backing persistence records.If you are willing to deal with the trouble that comes from depending on the persistence layer records inside your domain, and the possibility that other developers will expose the underlying record in subtle ways, then composing the record into the domain may be your best bet.The most formally-correct approach is to map the record fields over to domain object properties. This level of separation makes testing and modification of application logic much easier in the long run, but it takes a lot of time, attention, and discipline."},{"id":"\/skeleton\/getting-started.html#2-1","title":"2.1. Skeleton Generator","content":"This is the command-line interface package for Atlas. It is intended for use in your development environments, not your production ones."},{"id":"\/skeleton\/getting-started.html#2-1-1","title":"2.1.1. Installation","content":"This package is installable and autoloadable via Composer as atlas\/cli.Add it to the require-dev section of your root-level composer.json to install the atlas-skeleton command-line tool.{ \"require-dev\": { \"atlas\/cli\": \"~1.0\" } } "},{"id":"\/skeleton\/getting-started.html#2-1-2","title":"2.1.2. Creating Skeleton Classes","content":"You can create your data source classes by hand, but it's going to be tedious to do so. Instead, use the atlas-skeleton command to read the table information from the database.Create a PHP file to return an array of connection parameters suitable for PDO:&lt;?php \/\/ \/path\/to\/conn.php return [ 'mysql:dbname=testdb;host=localhost', 'username', 'password' ]; ?&gt; You can then invoke the skeleton generator using that connection. Specify a target directory for the skeleton files, and pass the namespace name for the data source classes. You can pass an explicit table name to keep the generator from trying to guess the name..\/vendor\/bin\/atlas-skeleton.php \\ --conn=\/path\/to\/conn.php \\ --dir=src\/App\/DataSource \\ --table=threads \\ App\\\\DataSource\\\\Thread  N.b.: The backslashes (\\) at the end of the lines are to allow the command to be split across multiple lines in Unix. If you are on Windows, omit the trailing backslashes and enter the command on a single line. That will create this directory and two classes in src\/App\/DataSource\/:\u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Thread \u00c2 \u00c2 \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ThreadMapper.php \u00c2 \u00c2 \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ThreadTable.php The Mapper class will be empty, and the Table class will a description of the specified --table.Do that once for each SQL table in your database.If you pass --full to atlas-skeleton, it will additionally generate empty MapperEvents, Record, RecordSet, and TableEvents classes. (These are useful only if you want to add custom behaviors.)"}]